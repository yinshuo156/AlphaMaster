# Genetic-Alpha generated factor 2
import numpy as np
import pandas as pd

# 导入Genetic-Alpha的函数
import sys
sys.path.insert(0, str(r'c:\Users\Administrator\Desktop\alpha-master\Genetic-Alpha-main'))
try:
    from functions import *
    from utilities import *
except ImportError:
    # 如果无法导入，提供基础实现
    def decay_linear(x, decay_period):
        """线性衰减计算"""
        weights = np.arange(1, decay_period + 1) / sum(range(1, decay_period + 1))
        result = np.zeros_like(x)
        for i in range(len(x)):
            if i >= decay_period - 1:
                result[i] = np.sum(x[i-decay_period+1:i+1] * weights)
            else:
                result[i] = np.nan
        return result
    
    def ts_rank(x, window):
        """时间序列排序"""
        result = np.zeros_like(x)
        for i in range(len(x)):
            if i >= window - 1:
                window_data = x[i-window+1:i+1]
                result[i] = (window_data <= x[i]).sum() / window
            else:
                result[i] = np.nan
        return result
    
    def delta(x, periods):
        """计算差值"""
        result = np.zeros_like(x)
        result[periods:] = x[periods:] - x[:-periods]
        result[:periods] = np.nan
        return result


def calculate_factor(stock_data):
    """Calculate factor based on genetic programming result"""
    # Factor generated by Genetic-Alpha
    # Original expression: delta(ts_rank(decay_linear(close, 5.000), 4.000), 2.000)

    # Calculate basic derived features
    stock_data['returns'] = stock_data['close'] / stock_data['close'].shift(1) - 1
    stock_data['range'] = stock_data['high'] - stock_data['low']
    stock_data['hlc3'] = (stock_data['high'] + stock_data['low'] + stock_data['close']) / 3

    # Implement factor calculation based on genetic programming result
    try:
        # 实现表达式: delta(ts_rank(decay_linear(close, 5.000), 4.000), 2.000)
        # 1. 计算线性衰减
        close_values = stock_data['close'].values
        decay_result = decay_linear(close_values, 5.000)
        
        # 2. 计算时间序列排名
        rank_result = ts_rank(decay_result, 4.000)
        
        # 3. 计算差值
        factor_value = delta(rank_result, 2.000)
        
        # 转换为Series并处理缺失值
        factor_value = pd.Series(factor_value, index=stock_data.index)
        factor_value = factor_value.replace([np.inf, -np.inf], np.nan)
        return factor_value
    except Exception as e:
        # Fallback calculation if expression execution fails
        print(f'Factor calculation error: {e}')
        return stock_data['returns']  # Default to returns if error occurs
